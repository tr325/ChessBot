# TODO next:
Re-read RvR's talk notes! (Or even re-watch?)
Get move tables.
Achieve DEPTH = 2
? New 'Position' class? Seems to be annoying in a vriety of places


===================================================================
"true" board calculates move tree.
As depth increases the board state changes. THis is calculated by Move, and so therefore should live on a Node.
So, each move should be applied to a copy of the currentBoard, and then saved onto Node.
Further child moves should use Node's board as currentBoard

... except Move has board on it. Piece.getValidMoves is passed a board. move is then created with that board. 
getValidMoves is called from Board.popoulteNodetree. So can pass through a cloned board, and save that to the Move, not the Node
Move.apply9 then directly edits the board that's passed. But htat has to be done after evaulation because each of the possible valid moves for a piece would use the csame currentBoard object


===================================================================
Piece needs to know it's own position. Also add in "is_alive". Board no longer needs to know positions, can just ask all pieces. iterate over live pieces asking for position. Innefficient? Do I care?

Board has 'live' version, and the searched versions for the tree are made by cloning htat state, then applying the moves down the tree.
- ?? do you need to traverse both ways?

Piece knows possible moves, and its current position
- ie. the tranforms it can go to. 

Move knows is_valid, and stores that move's transform and piece.
- needs: Board. Transform. piece

Nodes are all the is_valid moves 

Gets value of move by trying every valid move. From current position. knows transforms, asks board if newPos is valid.

Node stores value of valid moves, and their parent/children/depth. THis allows board state to be recalculated. Tree keeps array of arrays of [current level of tree][node]

Recursively find all valid moves until depth == N, searching at each recursion. (later concern)

